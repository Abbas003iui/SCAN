<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Light Spectrum Analyzer</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    background: #f5f5f5;
    padding: 20px;
  }
  #uploadedImage {
    max-width: 400px;
    max-height: 300px;
    margin-top: 20px;
    border: 1px solid #ccc;
    display: none;
  }
  #spectrumChart {
    max-width: 90%;
    margin: 20px auto;
  }
</style>
</head>
<body>
<h1>Light Spectrum Analyzer</h1>
<input type="file" id="upload" accept="image/*" />
<br />
<img id="uploadedImage" alt="Uploaded Image" />
<canvas id="spectrumChart" width="800" height="400"></canvas>

<script>
  const imgElem = document.getElementById('uploadedImage');
  const canvas = document.getElementById('spectrumChart');
  const ctx = canvas.getContext('2d');
  let chartInstance = null;

  // Adjusted getColor function with alpha parameter for saturation control
  function getColor(wavelength, alpha=0.85) {
    if (wavelength < 380 || wavelength > 750) return `rgba(0,0,0,0)`;
    let r=0,g=0,b=0;
    if (wavelength < 440) {
      r = -(wavelength - 440) / (440 - 380);
      b = 1;
    } else if (wavelength < 490) {
      g = (wavelength - 440) / (490 - 440);
      b = 1;
    } else if (wavelength < 510) {
      g = 1;
      b = -(wavelength - 510) / (510 - 490);
    } else if (wavelength < 580) {
      r = (wavelength - 510) / (580 - 510);
      g = 1;
    } else if (wavelength < 645) {
      r = 1;
      g = -(wavelength - 645) / (645 - 580);
    } else {
      r = 1;
    }
    return `rgba(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)},${alpha})`;
  }

  // Creates a horizontal gradient across the canvas width to fill area with spectral colors
  function createSpectrumGradient(ctx, width) {
    const gradient = ctx.createLinearGradient(0, 0, width, 0);
    const step = 10;
    for(let wl=380; wl<=750; wl+=step) {
      const pos = (wl - 380) / (750 - 380);
      gradient.addColorStop(pos, getColor(wl));
    }
    return gradient;
  }

  // Analyzes image brightness spectrum horizontally, normalizes, and draws chart
  function analyzeImage(img) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    tempCtx.drawImage(img, 0, 0);

    const spectrum = [];
    const startWavelength = 380;
    const endWavelength = 750;
    const width = img.width;

    for(let x=0; x<width; x++) {
      let sum = 0;
      for(let y=0; y<img.height; y++) {
        const pixel = tempCtx.getImageData(x, y, 1, 1).data;
        sum += (pixel[0] + pixel[1] + pixel[2]) / 3;
      }
      spectrum.push(sum / img.height);
    }

    const maxVal = Math.max(...spectrum);
    const normSpectrum = spectrum.map(v => v / maxVal);
    const labels = normSpectrum.map((_, i) => Math.round(startWavelength + (i/width)*(endWavelength - startWavelength)));

    // Find peak data
    const peakIndex = normSpectrum.indexOf(Math.max(...normSpectrum));
    const peakWavelength = labels[peakIndex];
    const peakValue = normSpectrum[peakIndex].toFixed(3);

    // Destroy previous chart if exists to prevent overlaps
    if(chartInstance) {
      chartInstance.destroy();
    }

    // Gradient fill for area under the curve with saturated spectral colors
    const gradient = createSpectrumGradient(ctx, canvas.width);

    chartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Normalized Intensity',
            data: normSpectrum,
            borderColor: 'black',
            backgroundColor: gradient,
            fill: true,
            tension: 0.3,
            pointRadius: 0
          },
          {
            label: 'Peak',
            data: labels.map((wl, i) => i === peakIndex ? normSpectrum[i] : null),
            borderColor: 'red',
            backgroundColor: 'red',
            pointRadius: 7,
            pointHoverRadius: 9,
            showLine: false
          }
        ]
      },
      options: {
        responsive: true,
        scales: {
          x: {
            title: { display: true, text: 'Wavelength (nm)' },
            min: 380,
            max: 750,
            ticks: { maxTicksLimit: 10, autoSkip: true }
          },
          y: {
            title: { display: true, text: 'Normalized Absorbance' },
            min: 0,
            max: 1
          }
        },
        plugins: {
          title: {
            display: true,
            text: `Light Spectrum Intensity - Peak: ${peakWavelength} nm, Absorbance: ${peakValue}`
          },
          tooltip: {
            callbacks: {
              label: ctx => `Absorbance: ${ctx.formattedValue}`
            }
          },
          legend: {
            display: false
          }
        }
      },
      plugins: [{
        id: 'peakLine',
        afterDraw(chart) {
          const xScale = chart.scales.x;
          const yScale = chart.scales.y;
          const ctx = chart.ctx;
          const peakPixel = xScale.getPixelForValue(peakWavelength);

          ctx.save();
          ctx.beginPath();
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 1;
          ctx.setLineDash([5,5]);
          ctx.moveTo(peakPixel, yScale.top);
          ctx.lineTo(peakPixel, yScale.bottom);
          ctx.stroke();
          ctx.restore();
        }
      }]
    });
  }

  // Event listener for file upload
  document.getElementById('upload').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      imgElem.src = evt.target.result;
      imgElem.style.display = 'block';
      imgElem.onload = () => analyzeImage(imgElem);
    };
    reader.readAsDataURL(file);
  });
</script>
</body>
</html>
