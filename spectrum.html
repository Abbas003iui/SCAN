<script>
  const startWavelength = 380;
  const endWavelength = 750;
  const epsilon = 1e-6; // small number to avoid log(0)
  let blankSpectrum = null;
  let chart = null;

  // Efficient luminance grayscale extraction per vertical slice
  function extractSpectrum(img) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);

    const imageData = ctx.getImageData(0, 0, img.width, img.height).data;
    const spectrum = [];

    for (let x = 0; x < img.width; x++) {
      let sumLum = 0;
      for (let y = 0; y < img.height; y++) {
        const idx = (y * img.width + x) * 4;
        const r = imageData[idx];
        const g = imageData[idx + 1];
        const b = imageData[idx + 2];
        // Luminance formula for perceived brightness
        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
        sumLum += lum;
      }
      spectrum.push(sumLum / img.height);
    }

    return spectrum;
  }

  // Convert wavelength (nm) to RGB color with smooth gradient
  // Source: approximate visible spectrum RGB mapping
  function wavelengthToRGB(wavelength) {
    let R = 0, G = 0, B = 0;
    if (wavelength >= 380 && wavelength < 440) {
      R = -(wavelength - 440) / (440 - 380);
      G = 0;
      B = 1;
    } else if (wavelength >= 440 && wavelength < 490) {
      R = 0;
      G = (wavelength - 440) / (490 - 440);
      B = 1;
    } else if (wavelength >= 490 && wavelength < 510) {
      R = 0;
      G = 1;
      B = -(wavelength - 510) / (510 - 490);
    } else if (wavelength >= 510 && wavelength < 580) {
      R = (wavelength - 510) / (580 - 510);
      G = 1;
      B = 0;
    } else if (wavelength >= 580 && wavelength < 645) {
      R = 1;
      G = -(wavelength - 645) / (645 - 580);
      B = 0;
    } else if (wavelength >= 645 && wavelength <= 750) {
      R = 1;
      G = 0;
      B = 0;
    }

    // Intensity correction near vision limits
    let factor = 1;
    if (wavelength >= 380 && wavelength < 420) {
      factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
    } else if (wavelength > 700 && wavelength <= 750) {
      factor = 0.3 + 0.7 * (750 - wavelength) / (750 - 700);
    }

    R = Math.round(255 * Math.pow(R * factor, 0.8));
    G = Math.round(255 * Math.pow(G * factor, 0.8));
    B = Math.round(255 * Math.pow(B * factor, 0.8));

    return `rgb(${R},${G},${B})`;
  }

  function plotSpectrum(sampleSpectrum, width) {
    const labels = sampleSpectrum.map((_, i) =>
      startWavelength + (i / width) * (endWavelength - startWavelength)
    );

    if (blankSpectrum && blankSpectrum.length !== sampleSpectrum.length) {
      alert("⚠️ Warning: Blank and sample images have different widths! Absorbance calculation may be incorrect.");
    }

    let absorbance = [];
    if (blankSpectrum && blankSpectrum.length === sampleSpectrum.length) {
      absorbance = sampleSpectrum.map((I, i) => {
        const I0 = blankSpectrum[i];
        // Avoid zero or negative values by adding epsilon
        const safeI = I < epsilon ? epsilon : I;
        const safeI0 = I0 < epsilon ? epsilon : I0;
        return Math.log10(safeI0 / safeI);
      });
    } else {
      absorbance = sampleSpectrum; // fallback: just show sample intensity if no blank
    }

    // Normalize absorbance to 0-1 for display purposes
    const maxAbs = Math.max(...absorbance);
    const minAbs = Math.min(...absorbance);
    const normAbsorbance = absorbance.map(a => (a - minAbs) / (maxAbs - minAbs));

    // Find peak absorbance on normalized scale
    const peakIndex = normAbsorbance.indexOf(Math.max(...normAbsorbance));
    const peakWavelength = Math.round(labels[peakIndex]);
    const peakValue = normAbsorbance[peakIndex].toFixed(2);

    const dataPoints = labels.map((label, i) => ({
      x: label,
      y: normAbsorbance[i]
    }));

    const ctx = document.getElementById('spectrumChart').getContext('2d');
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: [{
          label: 'Absorbance (normalized 0-1)',
          data: dataPoints,
          fill: true,
          borderColor: 'black',
          pointRadius: 0,
          tension: 0.3,
          backgroundColor: function(ctx) {
            const chartArea = ctx.chart.chartArea;
            if (!chartArea) return null;

            const gradient = ctx.chart.ctx.createLinearGradient(chartArea.left, 0, chartArea.right, 0);
            // Create fine gradient stops for smooth color transition
            const steps = 50;
            for (let i = 0; i <= steps; i++) {
              const w = startWavelength + (i / steps) * (endWavelength - startWavelength);
              gradient.addColorStop(i / steps, wavelengthToRGB(w));
            }
            return gradient;
          }
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 2,
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'Wavelength (nm)' },
            min: startWavelength,
            max: endWavelength
          },
          y: {
            title: { display: true, text: 'Normalized Absorbance' },
            min: 0,
            max: 1,
            beginAtZero: true
          }
        },
        plugins: {
          title: {
            display: true,
            text: `Peak Absorbance (normalized): ${peakValue} at ${peakWavelength} nm`
          },
          tooltip: {
            callbacks: {
              label: ctx => `λ: ${ctx.raw.x.toFixed(0)} nm | A: ${ctx.raw.y.toFixed(2)}`
            }
          },
          legend: { display: false }
        }
      }
    });
  }

  function handleImageUpload(event, isBlank) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(evt) {
      const img = new Image();
      img.onload = function() {
        const spectrum = extractSpectrum(img);
        if (isBlank) {
          blankSpectrum = spectrum;
          document.getElementById('blankPreview').src = img.src;
          document.getElementById('blankPreview').style.display = 'inline';
          alert("✅ Blank (calibration) image loaded.");
        } else {
          document.getElementById('samplePreview').src = img.src;
          document.getElementById('samplePreview').style.display = 'inline';
          plotSpectrum(spectrum, img.width);
        }
      };
      img.src = evt.target.result;
    };
    reader.readAsDataURL(file);
  }

  document.getElementById('blankUpload').addEventListener('change', e => handleImageUpload(e, true));
  document.getElementById('sampleUpload').addEventListener('change', e => handleImageUpload(e, false));
</script>
